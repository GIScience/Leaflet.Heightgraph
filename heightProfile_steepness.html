<title>Coordinate viewing test page</title>
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
   <style>
     html, body, #map {
        height:100%;
        width:100%;
        padding:0px;
        margin:0px;
     }
     .d3-tip {
  
  padding: 4px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
  font-size: 8px;
  font-family: calibri;
}
/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}
/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}
  </style>

  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
  <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css" />
  
  <script type="text/javascript" src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js"></script>
  <script type="text/javascript" src="../dist/leaflet.elevation-0.0.4.min.js"></script>

  <!--[if lte IE 8]><link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.ie.css" /><![endif]-->

  <link rel="stylesheet" href="../dist/leaflet.elevation-0.0.4.css" />

  <script type="text/javascript" src="../dist/leaflet.elevation-0.0.4.min.js"></script>
 </head>
<body>
  <!-- <div id="map"></div> -->

  <script type="text/javascript">
    //   var map = new L.Map('map');

    // var url = 'http://otile{s}.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpeg',
    //   attr ='Tiles Courtesy of <a href="http://www.mapquest.com/">MapQuest</a> &mdash; Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
    //   service = new L.TileLayer(url, {subdomains:"1234",attribution: attr});

    // var bounds = new L.LatLngBounds(new L.LatLng(-44.6, 170), new L.LatLng(-45, 168));

    // map.addLayer(service).fitBounds(bounds);

var newgeojson = {
    "type": "FeatureCollection",
    "features": [{
        "type": "Feature",
        "geometry": {
            "type": "LineString",
            "coordinates": [
                [169.13693, -44.696476, 296],
                [169.134602, -44.69764, 295],
                [169.129983, -44.701164, 299],
                [169.131292, -44.702382, 303],
                [169.13376, -44.704533, 315]
            ]
        },
        "properties": {
            "steepness": 1
        }
    }, {
        "type": "Feature",
        "geometry": {
            "type": "LineString",
            "coordinates": [
                [169.135568, -44.705574, 336],
                [169.136179, -44.70934, 338],
                [169.137011, -44.714066, 344],
                [169.136984, -44.719489, 342],
                [169.136898, -44.725235, 350],
                [169.136801, -44.730143, 353],
                [169.135632, -44.734853, 354]
            ]
        },
        "properties": {
            "steepness": 0,
        }
    }, {
        "type": "Feature",
        "geometry": {
            "type": "LineString",
            "coordinates": [
                [169.131882, -44.738989, 363],
                [169.129688, -44.744241, 363],
                [169.123937, -44.746982, 361],
                [169.118509, -44.750286, 371],
                [169.112763, -44.753113, 374],
                [169.107807, -44.755356, 378],
                [169.103467, -44.758086, 386],
                [169.098902, -44.760956, 388],
                [169.096429, -44.764642, 397],
                [169.094197, -44.768246, 401],
                [169.091955, -44.773037, 402],
                [169.089251, -44.777194, 408],
                [169.086215, -44.780939, 410],
                [169.083227, -44.785498, 412],
                [169.079778, -44.788926, 423],
                [169.076913, -44.7923, 429]
            ]
        },
        "properties": {
            "steepness": -1,
        }
    }, {
        "type": "Feature",
        "geometry": {
            "type": "LineString",
            "coordinates": [
                [169.074059, -44.795938, 429],
                [169.071495, -44.800213, 435],
                [169.069505, -44.804263, 442],
                [169.067574, -44.809322, 436],
                [169.065508, -44.812728, 450],
                [169.063277, -44.817299, 451],
                [169.062, -44.822073, 447],
                [169.06023, -44.826622, 464],
                [169.058905, -44.831729, 459],
                [169.05553, -44.835645, 460],
                [169.051888, -44.83933, 467],
                [169.048626, -44.842817, 476],
                [169.045467, -44.846106, 480],
                [169.042028, -44.849287, 485],
                [169.037672, -44.851776, 493],
                [169.033477, -44.854367, 495],
                [169.029974, -44.856373, 502],
                [169.027324, -44.857559, 514],
                [169.023832, -44.859275, 518],
                [169.020587, -44.861743, 524],
                [169.017615, -44.864414, 526],
                [169.015748, -44.868888, 520],
                [169.013119, -44.872059, 529],
                [169.009879, -44.874521, 536]
            ]
        },
        "properties": {
            "steepness": -2,
        }
    }]
};

//Abfrage ob Steepness vorhanden
if (typeof(newgeojson.features[0].properties.steepness) !== 'undefined'){

    //Distanzen zwischen einzelnen Wegpunkten berechnen --> f√ºr die Breite der Bars
    //last und first: um Abstand zwischen letzter Koordinate des ersten und ersten Koordinate des zweiten Koordinatenblocks zu berechnen
    var distance= [], steepness=[];
    var first;
    for (var i=0; i<newgeojson.features.length; i++){
      for(var j=0; j<newgeojson.features[i].geometry.coordinates.length-1; j++){
        var g = new L.LatLng(newgeojson.features[i].geometry.coordinates[j][1], newgeojson.features[i].geometry.coordinates[j][0]);
        var h = new L.LatLng(newgeojson.features[i].geometry.coordinates[j+1][1], newgeojson.features[i].geometry.coordinates[j+1][0]);
        var calc = g.distanceTo(h);
        distance.push(calc);
      }
      var last =new L.LatLng(newgeojson.features[i].geometry.coordinates[newgeojson.features[i].geometry.coordinates.length-1][1], newgeojson.features[i].geometry.coordinates[newgeojson.features[i].geometry.coordinates.length-1][0]);
      if (i>0){
        first = new L.LatLng(newgeojson.features[i].geometry.coordinates[0][1], newgeojson.features[i].geometry.coordinates[0][0]);
        calc= last.distanceTo(first);
        distance.push(calc);
      }
    }
    var totaldistance = distance.reduce(function(a, b) { return a + b; }, 0);

    //hoehenangaben und steepness aus den Daten filtern
    var heightvalue=[];
    for (var i=0; i<newgeojson.features.length; i++){
      for(var j=0; j<newgeojson.features[i].geometry.coordinates.length; j++){
          heightvalue.push(newgeojson.features[i].geometry.coordinates[j][2]);
          steepness.push(newgeojson.features[i].properties.steepness);
      }
    } 
    //x-Wert(Position) berechnen
    var count= heightvalue.length;
    var adddist=[0];
    for (var i=1; i<count; i++){
      adddist[i]=adddist[i-1]+distance[i-1];  
    }
    //Data for svg-line-path 
    var lineData=[], polygonData=[];
    for (var i=0;i<count;i++){
      lineData.push({coords:[{x:adddist[i], y:heightvalue[i]},{x:adddist[(i+1==count)?i:i+1], y:heightvalue[(i+1==count)?i:i+1]}], steepness:steepness[i]});
      polygonData.push({coords:[{x:adddist[i], y:heightvalue[i]},{x:adddist[(i+1==count)?i:i+1], y:heightvalue[(i+1==count)?i:i+1]},
        {x:adddist[(i+1==count)?i:i+1], y:d3.min(heightvalue)},{x:adddist[i], y:d3.min(heightvalue)}], steepness:steepness[i]});
    }
    
    //SVG area
    var margin = {top: 20, right: 20, bottom: 70, left: 40},
      width = 500 - margin.left - margin.right,
      height = 300 - margin.top - margin.bottom;

    //domain = data space
    //range = screen space
    var x = d3.scale.linear()
      .range([0, width])
      .domain([0, totaldistance]);

    var y = d3.scale.linear()
      .range([height, 0])
      .domain(d3.extent(heightvalue, function(d) { return d }));

    var xAxis = d3.svg.axis()
      .scale(x)
      .orient("bottom");
      //.ticks(1);

    var yAxis = d3.svg.axis()
      .scale(y)
      .orient("left");

    //tooltips with height
    var tip = d3.tip()
      .attr('class', 'd3-tip')
      .offset([-10, 0])
      .html(function(d) {
        return  ((d.coords[0].y+d.coords[1].y)/2) ;
      });

    var svgSec = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", 
            "translate(" + margin.left + "," + margin.top + ")");

    svgSec.call(tip);

    svgSec.append('g')      
      .attr("transform", "translate(0," + height + ")")      // create a <g> element
      .attr('class', 'x axis') // specify classes
      .call(xAxis);

    svgSec.append('g')
      .attr('class', 'y axis')
      .call(yAxis);

    svgSec.selectAll('.axis line, .axis path')
     .style({'stroke': 'Black', 'fill': 'none', 'stroke-width': '1'});

    var legendData = [{steepness:'15%', color:'red'}, {steepness:'10%', color:'orange'}, {steepness:'5%', color:'yellow'},{steepness:'0%', color:'greenyellow'}];
     
    var legendRectSize = 7;
    var legendSpacing = 7;

    var legend = svgSec.selectAll('.legend')
      .data(legendData)
      .enter()
      .append('g')
      .attr('class', 'legend')
      .attr('transform', function(d, i) {
        var height = legendRectSize + legendSpacing;
        var offset =  height * 2;
        var horz = -2 * legendRectSize;
        var vert = i * height - offset;
        return 'translate(' + horz + ',' + vert + ')';
      });

    legend.append('rect')
      .attr('width', legendRectSize)
      .attr('height', legendRectSize)
      .attr('x', 30)
      .attr('y', 30)
      .style('fill', function(d){
           return ( d.color);});

    legend.append('text')
    .attr('x', 40)
    .attr('y', 36)
    .style('font-size', 10)
    .style('font-family', 'calibri')
    .text(function(d) { return d.steepness; });

    //bars as polygons (path)
    var polygon = d3.svg.line()
        .x(function(d) { return x(d.x); })
        .y(function(d) { return y(d.y); });

    svgSec.selectAll('hpath')
     .data(polygonData)
     .enter()
     .append('path')
     //.attr('leafletId', id)
     .attr('d', function(d) {return polygon(d.coords);})
     //.attr("data-legend",function(d) { return d.steepness})
     .attr("fill-opacity", 0.6)
     .attr('fill', function(d){
       return ( d.steepness ==-2 ?
           "red" : d.steepness ==-1 ? 
           "orange": d.steepness == 0 ? 
           "yellow" : d.steepness == 1 ? 
           "greenyellow" : "greenyellow")
      })
      .on('mouseover', handleMouseOver)
      .on("mouseout", handleMouseOut);


  // Create Event Handlers for mouse
    function handleMouseOver(d, i) {                
          // Use D3 to select element, change color and size
      tip.show(d);
        d3.select(this)
        .style({"fill": "black"
        })
        .attr("fill-opacity", 1);              
    }

    function handleMouseOut(d, i) {
      // Use D3 to select element, change color back to normal
      tip.hide(d);
      d3.select(this)
      .style("fill", function(d) {
        var returncolor;
        if (d.steepness == -2){
          returncolor ="red";
        } else if (d.steepness == -1){
            returncolor ="orange";
        } else if (d.steepness == 0){
            returncolor ="yellow";
        } else if (d.steepness == 1){
            returncolor ="greenyellow";
        } else if (d.steepness == -1){
            returncolor ="green";
        }
        return returncolor;
        })
        .attr("fill-opacity", 0.6);
    }
}
  </script>
</body>
</html>


 